<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dequn&#39;s blog</title>
  
  <subtitle>这些文章没啥用</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dequn.github.io/"/>
  <updated>2019-01-17T15:23:36.942Z</updated>
  <id>http://dequn.github.io/</id>
  
  <author>
    <name>dequn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DRF DateTime转换为时间戳</title>
    <link href="http://dequn.github.io/2019/01/17/drf-datetime-timestamp-serializer/"/>
    <id>http://dequn.github.io/2019/01/17/drf-datetime-timestamp-serializer/</id>
    <published>2019-01-17T13:43:59.000Z</published>
    <updated>2019-01-17T15:23:36.942Z</updated>
    
    <content type="html"><![CDATA[<p>将时间转化为时间戳输出给前端，可以减少前端工作量，毕竟从时间戳转换为本地时间很简单，也减少了时区转换的麻烦。但是DRF本身是没有提供时间戳输出选项的，准确的是python的<code>strftime</code>并没有提供标准的时间戳输出格式，但是<code>%s</code>作为GNU 扩展的时间输出格式，因此DRF的<a href="https://stackoverflow.com/questions/26083583/serialize-a-datetime-as-an-integer-timestamp" target="_blank" rel="noopener"><code>DATETIME_FORMAT</code>可以设置为’%s’</a>，能够输出时间戳字符串（注意，不是数字，是字符串)，但是不要高兴的太早，如果不是UTC时间，那么这样设置是有问题的。</p><p>在最开始并没有注意输出的时间戳值有什么不对，直到前端的小伙伴跟我反应我传给他的时间戳与他POST给我的不一样啊，差了8个小时，还不是比本地时间少了8个小时，而是多出了8个小时，这就很奇怪了，赶紧上数据库里边瞅一眼，发现时间以及时区都是正确的（Django托管的Postgresql 只存储UTC时间，读出来的时候会自动转换为本地时间），那么肯定就是’%s’这个时间格式化出的幺蛾子了。</p><p>查看DRF的<code>DateTimeField</code>的源码，发现其<code>to_representaton</code>函数并没有做特殊处理，所以问题所在应该是python的datetime的strftime方法了。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def to_representation(self, <span class="built_in">value</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">value</span>:</span><br><span class="line">        <span class="literal">return</span> None</span><br><span class="line"></span><br><span class="line">    output_format = getattr(self, <span class="string">'format'</span>, api_settings.DATETIME_FORMAT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output_format is None <span class="keyword">or</span> isinstance(<span class="built_in">value</span>, <span class="literal">six</span>.string_types):</span><br><span class="line">        <span class="literal">return</span> <span class="built_in">value</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">value</span> = self.enforce_timezone(<span class="built_in">value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output_format.<span class="built_in">lower</span>() == ISO_8601:</span><br><span class="line">        <span class="built_in">value</span> = <span class="built_in">value</span>.isoformat()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">value</span>.endswith(<span class="string">'+00:00'</span>):</span><br><span class="line">            <span class="built_in">value</span> = <span class="built_in">value</span>[:<span class="number">-6</span>] + <span class="string">'Z'</span></span><br><span class="line">        <span class="literal">return</span> <span class="built_in">value</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">value</span>.strftime(output_format)</span><br></pre></td></tr></table></figure></p><p>继续跟踪发现，datetime的strftime传入的参数是timetuple，问题也就在这里，根据Python官方文档说明，timetuple()返回的是本地时间元组，丢失了时区信息的，看下面的例子。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strftime</span><span class="params">(<span class="keyword">self</span>, fmt)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">"Format using strftime()."</span></span><br><span class="line">    <span class="keyword">return</span> _wrap_strftime(<span class="keyword">self</span>, fmt, <span class="keyword">self</span>.timetuple())</span><br></pre></td></tr></table></figure><blockquote><p><strong>date.timetuple()</strong><br> Return a time.struct_time such as returned by time.localtime().</p></blockquote><p>在Django shell 中测试，可以看到 <code>lt == t</code>，是同一时间，但他们的<code>timetuple()</code>不等，是各自的本地时间，’%s’格式化输出后也是不等的，CST时间要比UTC时间早8个小时，时间戳也就大出8个小时的秒数，但如果直接调用他们但timestamp()方法，则会发现其结果是一样的，即同一时刻，各个时区的时间戳都是一样的。 datetime还有一个<code>utctimetuple()</code>方法，从名字可以看出其返回的是UTC timetuple，可以肯定，<code>t</code>和<code>lt</code>的该方法调用结果是一样的。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">201</span>]: t</span><br><span class="line">Out[<span class="number">201</span>]: datetime.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">300000</span>, <span class="attr">tzinfo=&lt;UTC&gt;)</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: <span class="attr">lt</span> = timezone.localtime(t)</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: <span class="attr">lt</span> == t</span><br><span class="line">Out[<span class="number">203</span>]: True</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: t.timetuple()</span><br><span class="line">Out[<span class="number">204</span>]: time.struct_time(<span class="attr">tm_year=2019,</span> <span class="attr">tm_mon=1,</span> <span class="attr">tm_mday=17,</span> <span class="attr">tm_hour=1,</span> <span class="attr">tm_min=43,</span> <span class="attr">tm_sec=19,</span> <span class="attr">tm_wday=3,</span> <span class="attr">tm_yday=17,</span> <span class="attr">tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: lt.timetuple()</span><br><span class="line">Out[<span class="number">205</span>]: time.struct_time(<span class="attr">tm_year=2019,</span> <span class="attr">tm_mon=1,</span> <span class="attr">tm_mday=17,</span> <span class="attr">tm_hour=9,</span> <span class="attr">tm_min=43,</span> <span class="attr">tm_sec=19,</span> <span class="attr">tm_wday=3,</span> <span class="attr">tm_yday=17,</span> <span class="attr">tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: t.strftime('%s')</span><br><span class="line">Out[<span class="number">206</span>]: '<span class="number">1547689399</span>'</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: lt.strftime('%s')</span><br><span class="line">Out[<span class="number">207</span>]: '<span class="number">1547718199</span>'</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: t.timestamp()</span><br><span class="line">Out[<span class="number">208</span>]: <span class="number">1547689399.3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: lt.timestamp()</span><br><span class="line">Out[<span class="number">209</span>]: <span class="number">1547689399.3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: t.utctimetuple()</span><br><span class="line">Out[<span class="number">211</span>]: time.struct_time(<span class="attr">tm_year=2019,</span> <span class="attr">tm_mon=1,</span> <span class="attr">tm_mday=17,</span> <span class="attr">tm_hour=1,</span> <span class="attr">tm_min=43,</span> <span class="attr">tm_sec=19,</span> <span class="attr">tm_wday=3,</span> <span class="attr">tm_yday=17,</span> <span class="attr">tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: lt.utctimetuple()</span><br><span class="line">Out[<span class="number">212</span>]: time.struct_time(<span class="attr">tm_year=2019,</span> <span class="attr">tm_mon=1,</span> <span class="attr">tm_mday=17,</span> <span class="attr">tm_hour=1,</span> <span class="attr">tm_min=43,</span> <span class="attr">tm_sec=19,</span> <span class="attr">tm_wday=3,</span> <span class="attr">tm_yday=17,</span> <span class="attr">tm_isdst=0)</span></span><br></pre></td></tr></table></figure><p>在Python 的文档中也说明了，Python给出的格式化字符都是标准C覆盖的，各系统平台都可无差异运行，但是其他C平台扩展的也可以运行，能否支持就看Python的底层环境了。</p><blockquote><p>The full set of format codes supported varies across platforms, because Python calls the platform C library’s strftime() function, and platform variations are common. To see the full set of format codes supported on your platform, consult the strftime(3) documentation.</p></blockquote><blockquote><p>The following is a list of all the format codes that the C standard (1989 version) requires, and these work on all platforms with a standard C implementation. Note that the 1999 version of the C standard added additional format codes.</p></blockquote><p>找到了原因，也要给出解决方案，既然“标准”的格式不能直接输出时间戳，那么就自定义一个DateTimeField好了，在Serializer中使用自定义的DateTimeField来代替默认的DRF的DateTimeField即可得到时间戳，当然，如果有多个Model都有时间字段，我们可以直接继承自ModelSerializer，修改他的<code>serializer_field_mapping</code>，将时间类型的序列化字段类型修改为我们自定义的字段即可，代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTimeField</span><span class="params">(serializers.DateTimeField)</span>:</span></span><br><span class="line">    <span class="comment"># custom field</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(value.timestamp())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># modify default serializer_field_mapping</span></span><br><span class="line">    serializer_field_mapping = serializers.ModelSerializer.serializer_field_mapping</span><br><span class="line">    serializer_field_mapping[models.DateTimeField] = DateTimeField</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleModelSerializer</span><span class="params">(ModelSerializer)</span>:</span> <span class="comment"># our own ModelSerializer, not drf's serialiers.ModelSerializer</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将时间转化为时间戳输出给前端，可以减少前端工作量，毕竟从时间戳转换为本地时间很简单，也减少了时区转换的麻烦。但是DRF本身是没有提供时间戳输出选项的，准确的是python的&lt;code&gt;strftime&lt;/code&gt;并没有提供标准的时间戳输出格式，但是&lt;code&gt;%s&lt;/co
      
    
    </summary>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="DRF" scheme="http://dequn.github.io/tags/DRF/"/>
    
  </entry>
  
  <entry>
    <title>Charles和 Shadowsocks 共存设置说明</title>
    <link href="http://dequn.github.io/2019/01/13/how-to-resolve-confilcts-between-charles-and-shadowsocks/"/>
    <id>http://dequn.github.io/2019/01/13/how-to-resolve-confilcts-between-charles-and-shadowsocks/</id>
    <published>2019-01-13T05:51:03.000Z</published>
    <updated>2019-01-13T07:58:43.715Z</updated>
    
    <content type="html"><![CDATA[<p>该文的说明解释可能需要如下的软件及环境：<br><em><br>Chrome v71.0.3578.98<br>macOS v10.13.6<br>Charles v4.2.7<br>ShadowsocksX-NG v1.8.2 (1)</em></p><hr><p>Charles作为一款HTTP(S)抓包工具非常好用，不过国内的用户基本上还都挂Shadowsocks翻墙了，系统代理只能有一个（注意是系统代理，一般软件也都可以配置自己的代理服务），在macOS上，Chrome默认使用的就是系统代理(单独设置代理请参考<a href="https://my.oschina.net/u/147181/blog/164872" target="_blank" rel="noopener">为谷歌chrome浏览器设置独立代理服务器</a>)，所以如果想要两者同时工作不冲突，还需要一些特别的设置。</p><p><a href="https://www.jianshu.com/p/ff114bdf0f8f" target="_blank" rel="noopener">charles与shadowsocks共存</a>说明了如果通过让所有HTTP(S)流量都走Charles，然后Charles 再设置外部代理（External Proxy)为Shadowsocks的本地代理即可，这样流量依次经过两个代理，既能抓包，又能翻墙。</p><p>不过这种方法需要一直开着Charles，不然翻不了墙（因为Charles已经取代Shadowsocks成为系统代理）。除了PAC模式，两款软件后启动或者切换模式(Shadowsocks的PAC, Global, Manual)的那一方会清除掉其他代理设置，改为目标设置。</p><p>一般情况下都会设置Shadowsocks随系统启动，我们多数又都是使用PAC模式，这样国内的网站就不走梯子了，速度快。所以打开Charles后，需要将Shadowsocks切换至Manual模式(即不设置系统代理，各软件自己配置代理)，不然流量优先通过PAC，Charles的HTTP(S)代理就不起作用了，当关闭Charles后，再将Shadowsocks切换至PAC或者Global，也可以保持Manual模式，各个软件自己配置代理。</p><p>让流量先通过Charles然后再通过Shadowsocks，注意这种模式已经不是Shadowsocks提供的PAC了，只能是Shadowsocks的HTTP(S)或者SOCKS5了（根据Charles的Extenal Proxy配置而定），如果是本地网站开发调试，需要把测试用的域名诸如localhost, 127.0.0.1或者是修改的hosts文件中的域名填入<strong>Charles External Proxy设置中的Bypass, 注意不是Charles Proxy Setting的Bypass，也不是系统WIFI设置代理的Bypass，后两者是不走Charles代理。</strong>由于走了梯子，前端的其他资源如CDN等某些资源可能加载失败或者是加载超时，需要当心。</p><p>这种方法既需要一直开着Charles/不断的切换Shadowsocks模式，又对国内网站抓包还不友好，所以还是比较鸡肋的，价值不大，简单的方式是：如果要抓包的软件可以单独设置代理，那么不要让Charles设置系统代理，配置各个软件的代理好了；如果不能，暂时性的抓包可以不翻墙，或者就忍受一下这种鸡肋的设置吧!</p><p>[1]. <a href="https://www.jianshu.com/p/ff114bdf0f8f" target="_blank" rel="noopener">charles与shadowsocks共存</a><br>[2]. <a href="https://www.charlesproxy.com/documentation/configuration/external-proxies/" target="_blank" rel="noopener">Charles</a><br>[3]. <a href="https://my.oschina.net/u/147181/blog/164872" target="_blank" rel="noopener">为谷歌chrome浏览器设置独立代理服务器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该文的说明解释可能需要如下的软件及环境：&lt;br&gt;&lt;em&gt;&lt;br&gt;Chrome v71.0.3578.98&lt;br&gt;macOS v10.13.6&lt;br&gt;Charles v4.2.7&lt;br&gt;ShadowsocksX-NG v1.8.2 (1)
&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Charles" scheme="http://dequn.github.io/tags/Charles/"/>
    
      <category term="Shadowsocks" scheme="http://dequn.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Django 国际化和本地化</title>
    <link href="http://dequn.github.io/2019/01/07/django-i18n-l10n/"/>
    <id>http://dequn.github.io/2019/01/07/django-i18n-l10n/</id>
    <published>2019-01-07T11:21:12.000Z</published>
    <updated>2019-01-19T06:24:18.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><p>很多不靠谱的文章上来第一步就是设置<code>LANGUAGE_CODE = &#39;zh-CN&#39;</code>，这明显是没看懂配置项的意思，从<a href="https://docs.djangoproject.com/en/2.1/topics/i18n/translation/#how-django-discovers-language-preference" target="_blank" rel="noopener">Django文档</a>可以看出， <strong> <code>LANGUAGE_CODE</code>只是最后的兜底设置 </strong>，所以这一步的设置完全没有必要，当然，如果站点确定只提供一种语言的服务，则需要设置并且不提供其他语言的翻译。</p><p>然后就是<code>USE_I18N</code>和<code>LocaleMiddleware</code>的配置了， <strong> 如果要提供两种语言以上的服务，那么必须设置<code>USE_I18N=True</code>并且配置<code>LocaleMiddleware</code> </strong>，<code>LocaleMiddleware</code>尽可能在其他中间件之前但必须在<code>SessionMiddleware</code>和<code>CacheMiddleware</code>之后，可能是这样的<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MIDDLEWARE</span> = [</span><br><span class="line">   <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">   <span class="string">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class="line">   <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong> <code>USE_L10N</code>是指用来配置诸如时间格式、数字格式（有没有千分位符号）等，跟多语言是没有直接关系的</strong> ，主要设置项可以参考文档或者源代码django.utils.formats.FORMAT_SETTINGS中的key值。</p><p>另外，如果翻译的文件不是在<code>INSTALLED_APPS</code>中的app的locale目录下，那么需要修改<code>LOCALE_PATHS</code>配置，让Django能够找到.mo文件。</p><h2 id="2-Django如何确定使用那种语言"><a href="#2-Django如何确定使用那种语言" class="headerlink" title="2. Django如何确定使用那种语言"></a>2. Django如何确定使用那种语言</h2><p><a href="https://docs.djangoproject.com/en/2.1/topics/i18n/translation/#how-django-discovers-language-preference" target="_blank" rel="noopener">how-django-discovers-language-preference</a>已经介绍的很详细了，各种方式有不同的优先级，根据需要选择就好了。</p><blockquote><p>首先，在当前用户的 session 的中查找django_language键；<br>    如未找到，它会找寻一个cookie<br>    还找不到的话，它会在 HTTP 请求头部里查找Accept-Language， 该头部是你的浏览器发送的，并且按优先顺序告诉服务器你的语言偏好。 Django会尝试头部中的每一个语种直到它发现一个可用的翻译。<br>    以上都失败了的话, 就使用全局的 LANGUAGE_CODE 设定值。</p></blockquote><h2 id="3-汉化到底是zh-Hans还是zh-CN-Django-v2-0-9"><a href="#3-汉化到底是zh-Hans还是zh-CN-Django-v2-0-9" class="headerlink" title="3. 汉化到底是zh_Hans还是zh_CN (Django v2.0.9)"></a>3. 汉化到底是zh_Hans还是zh_CN (Django v2.0.9)</h2><p>我看网上很多教程都是<code>makemessags -l zh_CN</code>，在Django (v2.0.9)中如此操作，发现完全没有生效，这里又是怎么回事呢？</p><p>从<code>django/middle/locale.py</code>我们可以看出在处理请求时，Django会首先根据【<a href="#Django如何确定使用那种语言">步骤2</a>】中的流程来判断客户端语言，其默认配置文件在<code>django/conf/locale/__init__.py</code>中，我们可以看到，<code>zh_Hans</code>是<code>zh-cn</code>以及其他简体中文的<em>fallback</em>项，也就是说如果客户端请求了<code>zh-cn</code>语言，服务器是按照<code>zh-Hans</code>语言返回的，也就是根据这个值——<code>zh-Hans</code>去<code>LOCALE_PAHTS</code>加载.mo文件完成多语言的。这也就是为什么<code>makemessages -l zh_CN</code>不生效的原因。</p><p>那么如何让在<em>zh_CN</em>目录下的翻译生效呢，很简单，配置<code>LANGUAGES</code>，添加<em>zh-cn</em>即可，这样Django就可以直接根据zh-cn来加载zh_CN目录下的.mo了，不过多数情况下并没有这种必要，除非同时提供了多种简体中文语言，并且各地区有差别。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LANGUAGES</span> += [</span><br><span class="line">    (<span class="string">'zh-cn'</span>, gettext_noop(<span class="string">'Simplified Chinese'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>参考</p><ol><li><a href="http://djangobook.py3k.cn/2.0/chapter19/" target="_blank" rel="noopener">第十九章： 国际化</a></li><li><a href="https://docs.djangoproject.com/en/2.1/topics/i18n/translation/#how-django-discovers-language-preference" target="_blank" rel="noopener">How Django discovers language preference</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1101_jinjh_djangoi18n/index.html" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/topics/i18n/translation/#how-django-discovers-language-preference</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-配置&quot;&gt;&lt;a href=&quot;#1-配置&quot; class=&quot;headerlink&quot; title=&quot;1. 配置&quot;&gt;&lt;/a&gt;1. 配置&lt;/h2&gt;&lt;p&gt;很多不靠谱的文章上来第一步就是设置&lt;code&gt;LANGUAGE_CODE = &amp;#39;zh-CN&amp;#39;&lt;/code
      
    
    </summary>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="I18N" scheme="http://dequn.github.io/tags/I18N/"/>
    
      <category term="L10N" scheme="http://dequn.github.io/tags/L10N/"/>
    
  </entry>
  
  <entry>
    <title>DRF serializer中外键post使用id，get获取详细信息</title>
    <link href="http://dequn.github.io/2018/12/23/drf-serializer-foreignkey-post-id-get-full-content/"/>
    <id>http://dequn.github.io/2018/12/23/drf-serializer-foreignkey-post-id-get-full-content/</id>
    <published>2018-12-23T07:30:01.000Z</published>
    <updated>2019-01-13T08:06:31.635Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Django REST framework Serializer的时候，并不一定单一的SerializerField就可以满足要求，比如遇到Model 中含有外键，如果<a href="https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations" target="_blank" rel="noopener">Writable nested representations</a>，则参考官方的例子重写<code>create</code>或者<code>update</code>方法就行，但如果要是想在<code>deserializering</code>的时候使用外键键值——object_id, <code>serializering</code>的时候表达出一些必要的信息，那么就需要对Serializer的字段进行一些特定的设置了。</p><p>根据Django 中对 ForeignKey的解释以及如何对ForeignKey查询对介绍</p><blockquote><h2 id="Database-Representation"><a href="#Database-Representation" class="headerlink" title="Database Representation"></a>Database Representation</h2><p>Behind the scenes, Django appends “_id” to the field name to create its database column name. In the above example, the database table for the Car model will have a manufacturer_id column.</p></blockquote><blockquote><p>The field specified in a lookup has to be the name of a model field. There’s one exception though, in case of a ForeignKey you can specify the field name suffixed with _id. In this case, the value parameter is expected to contain the raw value of the foreign model’s primary key.<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry<span class="selector-class">.objects</span><span class="selector-class">.filter</span>(blog_id=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>所以在使用<code>ModelSerializer</code>的时候，很简单就可以实现，假如我们Bar model中有一个外键字段<code>foo</code>，那么BarSerializer可以有如下的定义：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BarSerializer</span>(<span class="title">serializers</span>.<span class="type">ModelSerializer</span>):</span></span><br><span class="line"><span class="class">    foo_id = serializers.<span class="type">IntegerField</span>(<span class="title">write_only</span>=<span class="type">True</span>)</span></span><br><span class="line"><span class="class">    foo = <span class="type">FooSerializer</span>(<span class="title">read_only</span>=<span class="type">True</span>)</span></span><br></pre></td></tr></table></figure></p><p>在POST请求中，传入的字段名称为foo_id即可。而GET的时候，会使用FooSerializer对foo进行序列化，得到完整对外键内容。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://stackoverflow.com/questions/36189303/django-rest-framework-receive-primary-key-value-in-post-and-return-model-object/53827209#53827209" target="_blank" rel="noopener">https://stackoverflow.com/questions/36189303/django-rest-framework-receive-primary-key-value-in-post-and-return-model-object/53827209#53827209</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Django REST framework Serializer的时候，并不一定单一的SerializerField就可以满足要求，比如遇到Model 中含有外键，如果&lt;a href=&quot;https://www.django-rest-framework.org/api
      
    
    </summary>
    
      <category term="Django" scheme="http://dequn.github.io/categories/Django/"/>
    
    
      <category term="DRF" scheme="http://dequn.github.io/tags/DRF/"/>
    
      <category term="foreign key" scheme="http://dequn.github.io/tags/foreign-key/"/>
    
  </entry>
  
  <entry>
    <title>一次可怕的误操作-暨IDE的重要性</title>
    <link href="http://dequn.github.io/2018/11/03/yi-ci-ke-pa-de-wu-cao-zuo/"/>
    <id>http://dequn.github.io/2018/11/03/yi-ci-ke-pa-de-wu-cao-zuo/</id>
    <published>2018-11-03T13:11:11.000Z</published>
    <updated>2018-11-03T13:41:25.417Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前喜欢用VIM 敲代码，也跟着<a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener">yangyangwithgnu</a>的文档折腾过一段时间，不过随着几次换电脑、重装等（虽然配置也做了备份），热情逐渐退却，在项目开发中还是换回了IDE，平常写一些简单的脚本才会用VIM，也是第一反应，毕竟为了写两三个文件的代码是不需要用IDE的。也幸亏用了PyCharm，才免去了一次说大不大说小不小的损失。</p><p>手头的项目进入到实质开发阶段，之前更像Demo的系统无论从代码质量还是数据库设计、框架方面，都避免不了要重构一次，单元测试等该实现也要实现，说动手就动手，辛苦了两天基本完成了初期的重构，交代一下，由于本人没有在IDE中配置Docker及其环境，所以每次运行单元测试都是在终端<code>docker-compose run ... test ...</code>的。</p><p>也不得不说<code>Ctrl + R</code> 极大方便了重复执行命令（PS：个人很少能想起来直接 <code>Ctrl + P</code> 执行上一条命令，况且也不是所有的命令都是执行上一次），在有一次重启一个container 的时候，搜索 <em>res</em>(tart)，看也没看就敲回车运行，不过看到输出就崩溃了，<code>HEAD is now at ff156e1 ...</code>，原来找到的历史命令是<code>git reset --hard HEAD</code>，可这些重构都是<code>unstaged</code>的状态啊，万能的git也找不回来这些被<strong>reset</strong>的修改了！</p><p>万般无奈，两天的工作（虽然一天也写不了多少）重做会很快，但心情更重要啊，瞬间就想下班静一静了，哈哈哈哈。</p><p>正在准备出去溜达一圈换换脑子的时候，灵光一现，咱可是用了PyCharm的人啊，我记得她（注意用字，这就是让我重生的上帝啊）有一个<strong>Local History</strong> 的功能，这个<strong> Local History</strong>也是与Git 独立的，唯一的希望就是她了，命悬一线。</p><p>战战兢兢的在项目目录上点击<em> Local History -&gt; Show History </em>，谢天谢地啊，左侧历史列表很帅气、准确、救世主一样的显示出了每一次文件改动的记录，找到被reset到记录，也显示出了修改来源——<strong>External change</strong>， 检查无误恢复成功，悬着的心终于放下了。</p><p>不得不说，对JetBrain好感倍增！赶紧花钱去买一个正版对授权吧，还是那句话，心情很重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很早之前喜欢用VIM 敲代码，也跟着&lt;a href=&quot;https://github.com/yangyangwithgnu/use_vim_as_ide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yangyangwithgnu&lt;/a&gt;的文档折腾过一段时
      
    
    </summary>
    
    
      <category term="VIM" scheme="http://dequn.github.io/tags/VIM/"/>
    
      <category term="IDE" scheme="http://dequn.github.io/tags/IDE/"/>
    
      <category term="PyCharm" scheme="http://dequn.github.io/tags/PyCharm/"/>
    
  </entry>
  
  <entry>
    <title>Django添加用户Celery任务</title>
    <link href="http://dequn.github.io/2018/10/14/django-add-user-celery-task/"/>
    <id>http://dequn.github.io/2018/10/14/django-add-user-celery-task/</id>
    <published>2018-10-14T12:23:00.000Z</published>
    <updated>2018-10-14T14:02:53.762Z</updated>
    
    <content type="html"><![CDATA[<p>系统开发需要添加用户自己设定的定时任务，当然这种任务不是用户自己编程那种，而是写好的逻辑，用户设定参数执行即可。</p><p>上篇<a href="/2018/06/02/django-celery/" title="Django2结合Celery添加定时任务">Django2结合Celery添加定时任务</a>说明了如何利用Celery设定定时任务，这次需要用户添加自己的定时任务，总共分为步：</p><ol><li>写定时任务的代码，留出需要带入的参数；</li><li>设计Model，通过用户表单获取到定时任务的参数，比如执行时间、其他参数等；</li><li>注册Model 的<code>post_save</code> 或者 <code>pre_save</code> signal，添加或者删除<code>django_celery_beat.model.PeriodicTask</code> 记录;</li><li>如果不想让用户的定时任务与系统的定时任务都存在一张数据表中，可以新建继承自<code>django_celery_beat.model.PeriodicTask</code>的类，当然这样也就需要新建继承自<code>django_celery_beat.schedulers.DatabaseScheduler</code>类，从新建的Task类中分发任务。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统开发需要添加用户自己设定的定时任务，当然这种任务不是用户自己编程那种，而是写好的逻辑，用户设定参数执行即可。&lt;/p&gt;
&lt;p&gt;上篇&lt;a href=&quot;/2018/06/02/django-celery/&quot; title=&quot;Django2结合Celery添加定时任务&quot;&gt;Djan
      
    
    </summary>
    
      <category term="Django" scheme="http://dequn.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="Celery" scheme="http://dequn.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Twisted 服务间通信</title>
    <link href="http://dequn.github.io/2018/08/22/communication-between-twisted-services/"/>
    <id>http://dequn.github.io/2018/08/22/communication-between-twisted-services/</id>
    <published>2018-08-22T12:33:01.000Z</published>
    <updated>2019-01-13T08:08:03.745Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="/2018/06/19/django-channels-websocket-iot-remote-control/" title="基于Django & Channels & WebSocket & Twisted的物联网远程控制">基于Django & Channels & WebSocket & Twisted的物联网远程控制</a>】写到，下位机每隔一段时间连接上位机传送数据和进行任务下发，现在领导改需求了，要求使用长链接，使得上位机的任务可以随时下发，方便用户。小米的智能家电采取的应该也都是长链接的方式，由于小米家电本身是市电供应，家里也都是wifi上网，所以除了会多消耗服务器资源外，这种即时的控制还是蛮不错的。但是真正用于野外的物联网终端，还是要平衡好电量、流量的问题才行。</p><p>之前也提到，web网页用户操作，web后台生成并发布到redis订阅，Twisted 采用redis客户端监听，并在下位机连接的时候下发任务，这里我用的相当于是一个全局变量存下来哪些设备有任务，如果要改成长链接实时控制，这种方法就不太合适了。</p><p>上位机是一个单独的service，redis监听是一个单独的service，这就要求两个service能够通信——redis客户service告诉上位机服务serivce，有新任务啦，赶紧下发！</p><p>解决这个问题过程中，也加深了对Twisted的理解，重要的有三点，参考<a href="https://stackoverflow.com/questions/21344343/how-to-communicate-between-services" target="_blank" rel="noopener">[1]</a>。</p><ul><li>service不接收也不发送数据，只负责启动和停止factory</li><li>factory也不接收和发送数据，负责生成和销毁protocol实例，protocol实例处理链接和收发数据</li><li>factory是长生命周期的，protocol实例是用完就销毁的</li></ul><p>有了以上三点，事情就简单多了。</p><ul><li>创建redis client factory的时候，传入上位机服务factory</li><li>让上位机服务factory 维护一个protocol实例的集合，protocol实例创建时添加，销毁是删除</li><li>通过 redis_facotry.up_service_factory.protocol_set 获取上位机服务protocol实例，执行相应任务（长链接protocol实例不会被销毁）</li></ul><p>直接看代码:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FisheryProtocol</span>(<span class="title">protocol</span>.<span class="title">Protocol</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.factory.protocol_set.add(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionLost</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.factory.protocol_set.pop(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisProtocol</span>(<span class="title">redis</span>.<span class="title">SubscriberProtocol</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">messageReceived</span><span class="params">(<span class="keyword">self</span>, pattern, channel, message)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.factory.fishery_factory.protocol_set <span class="comment"># get a specified protocol from protocol_set  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisFactory</span>(<span class="title">redis</span>.<span class="title">SubscriberFactory</span>):</span></span><br><span class="line">    <span class="comment"># ... other code</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, fishery_factory)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>().__init_<span class="number">_</span>()</span><br><span class="line">        <span class="keyword">self</span>.fishery_factory = fishery_factory</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【&lt;a href=&quot;/2018/06/19/django-channels-websocket-iot-remote-control/&quot; title=&quot;基于Django &amp; Channels &amp; WebSocket &amp; Twisted的物联网远程控制&quot;&gt;基于Django &amp;
      
    
    </summary>
    
      <category term="Twisted" scheme="http://dequn.github.io/categories/Twisted/"/>
    
    
      <category term="Twisted" scheme="http://dequn.github.io/tags/Twisted/"/>
    
  </entry>
  
  <entry>
    <title>记一次Confluence迁移数据库和Docker network网络修改</title>
    <link href="http://dequn.github.io/2018/06/30/docker-network/"/>
    <id>http://dequn.github.io/2018/06/30/docker-network/</id>
    <published>2018-06-30T05:48:00.000Z</published>
    <updated>2018-06-30T06:17:10.822Z</updated>
    
    <content type="html"><![CDATA[<p>公司的Confluence越来越慢，查看了一下日志，好多数据库连接超过最大数错误，另外由于数据库有很多定时任务，磁盘读写频繁，所以选择在另一台机器上重建一个数据库。</p><p>由于Confluence是破解的，如果每次创建新容器序列号会变，所以原有的Confluence容器不能删除。</p><p>由于同一台机器可能有多个数据库实例服务于不同的应用，所以不能将数据库端口映射到主机上，那么在confluence中如何填写数据库连接呢？</p><p>Docker会默认将容器添加到<code>bridge</code>中，但是<code>bridge</code>网络内的容器不能通过容器名访问，所以需要新建network并将已有的Confluence容器和新建的数据库容器添加进来。如果一开始就决定是组合应用的话，使用docker-compose最方便，此次情况是作修改。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="built_in"> network </span>create confluence-network # 新建一个network</span><br><span class="line">docker<span class="built_in"> network </span>connect confluence-network herisk-confluence # 把容器herisk-confluence添加到confluence-network 中</span><br><span class="line">docker <span class="builtin-name">run</span> --name confluence-postgres -v confluence-postgres-db:/var/lib/postgresql/data -e <span class="attribute">POSTGRES_PASSWORD</span>=postgres <span class="attribute">--network</span>=confluence-network -d postgres #创建数据库容器并添加到confluence-network中</span><br></pre></td></tr></table></figure><p>备份和恢复数据库使用<code>pg_dump 和 pg_restore</code>比较简单，就不在赘述了。</p><p>修改Confluence 的配置文件<code>confluence.cfg.xml</code>，数据库连接的主机部分填写数据库容器名即可，本例中为<code>jdbc://confluence-postgres-db:5432/confluence</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://docs-cn.docker.octowhale.com/engine/userguide/networking/container-networking.html" target="_blank" rel="noopener">Docker container networking</a><br>[2]. <a href="https://help.aliyun.com/document_detail/26157.html" target="_blank" rel="noopener">使用 psql 命令迁移 PostgreSQL 数据</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司的Confluence越来越慢，查看了一下日志，好多数据库连接超过最大数错误，另外由于数据库有很多定时任务，磁盘读写频繁，所以选择在另一台机器上重建一个数据库。&lt;/p&gt;
&lt;p&gt;由于Confluence是破解的，如果每次创建新容器序列号会变，所以原有的Confluence
      
    
    </summary>
    
      <category term="Docker" scheme="http://dequn.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://dequn.github.io/tags/Docker/"/>
    
      <category term="network" scheme="http://dequn.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose 子目录编译、运行</title>
    <link href="http://dequn.github.io/2018/06/23/docker-compose-subdirectory-dockerfile/"/>
    <id>http://dequn.github.io/2018/06/23/docker-compose-subdirectory-dockerfile/</id>
    <published>2018-06-23T07:55:46.000Z</published>
    <updated>2019-01-13T08:08:40.549Z</updated>
    
    <content type="html"><![CDATA[<p>公司开发物联网业务，使用Twisted 基于TCP协议开发的上位机服务，使用Django开发的Web后端，虽然是分别开发的，但两个服务之间有一定的耦合，比如上篇【<a href="/2018/06/19/django-channels-websocket-iot-remote-control/" title="基于Django & Channels & WebSocket & Twisted的物联网远程控制">基于Django & Channels & WebSocket & Twisted的物联网远程控制</a>】就需要Web后端和Twisted共同完成，而Twisted上位机接收到下位机但上传数据后，是异步调用了Web后端进行数据入库的，所以两个服务还是一块启动的，再加上Redis, Postgresql数据库服务等，最终选择使用Docker Compose 一块发布管理。</p><p>两个服务是分开开发的，也就要放在不同的目录中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iot</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── tcp</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">└── web</span><br><span class="line">    └── Dockerfile</span><br></pre></td></tr></table></figure><p>docker-compose.yml文件内容</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">version</span>: <span class="string">'3'</span></span><br><span class="line"><span class="attribute">services</span>:</span><br><span class="line">    <span class="attribute">web</span>:</span><br><span class="line">        <span class="attribute">build</span>: ./web</span><br><span class="line">        <span class="attribute">image</span>: <span class="attribute">web</span>:backend</span><br><span class="line">        <span class="attribute">command</span>: [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"python3 manage.py runserver 0.0.0.0:8000"</span>]</span><br><span class="line">        <span class="attribute">ports</span>:</span><br><span class="line">            - <span class="string">"8000:8000"</span></span><br><span class="line">        <span class="attribute">depends_on</span>:</span><br><span class="line">            - pgdb</span><br><span class="line">            - redis</span><br><span class="line">        <span class="attribute">volumes</span>:</span><br><span class="line">            - ./<span class="attribute">web</span>:/code</span><br><span class="line"></span><br><span class="line">    <span class="attribute">twisted</span>:</span><br><span class="line">        <span class="attribute">build</span>: ./tcp</span><br><span class="line">        <span class="attribute">ports</span>:</span><br><span class="line">            - <span class="string">"21188:21188"</span></span><br><span class="line">        <span class="attribute">command</span>: [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"twistd -ny service.tac"</span>]</span><br><span class="line">        <span class="attribute">depends_on</span>:</span><br><span class="line">            - redis</span><br><span class="line">        <span class="attribute">volumes</span>:</span><br><span class="line">            - ./<span class="attribute">tcp</span>:/code</span><br><span class="line"></span><br><span class="line">    <span class="attribute">redis</span>:</span><br><span class="line">        <span class="attribute">image</span>: redis</span><br><span class="line"></span><br><span class="line">    <span class="attribute">pgdb</span>:</span><br><span class="line">        <span class="attribute">image</span>: postgres</span><br><span class="line">        <span class="attribute">environment</span>:</span><br><span class="line">            <span class="attribute">POSTGRES_PASSWORD</span>: postgres</span><br><span class="line">        <span class="attribute">volumes</span>:</span><br><span class="line">            - <span class="attribute">pg-vol</span>:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line"><span class="attribute">volumes</span>:</span><br><span class="line">    <span class="attribute">pg-vol</span>:</span><br></pre></td></tr></table></figure><p><code>tcp/Dockerfile</code> 和 <code>web/Dockerfile</code>的内容都是一样的，所不同的就是各自目录下的代码。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="bash">WORKDIR /code</span></span><br><span class="line"><span class="bash">ADD requirements.txt /code/</span></span><br><span class="line"><span class="bash">RUN pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txt</span></span><br><span class="line"><span class="bash">ADD . /code/</span></span><br></pre></td></tr></table></figure></p><p>这里讲一下需要注意的两个地方：</p><ul><li>docker-compose.yml中build后要加上目录，也可以用<code>context</code>参数指定</li><li>特别需要注意的，各个服务需要添加自己的volumes，也就是示例中的<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">volumes:</span></span><br><span class="line">    - .<span class="regexp">/web:/</span>code</span><br><span class="line"><span class="string">volumes:</span></span><br><span class="line">    - .<span class="regexp">/tcp:/</span>code</span><br></pre></td></tr></table></figure></li></ul><p>不然虽然能正常生成container，但运行的时候<code>/code</code>下内容趋势<code>iot</code>目录，不是单个服务下但目录代码，导致不能正常运行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://nickjanetakis.com/blog/docker-tip-10-project-structure-with-multiple-dockerfiles-and-docker-compose" target="_blank" rel="noopener">Docker Tip #10: Project Structure With Multiple Dockerfiles and Docker Compose</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司开发物联网业务，使用Twisted 基于TCP协议开发的上位机服务，使用Django开发的Web后端，虽然是分别开发的，但两个服务之间有一定的耦合，比如上篇【&lt;a href=&quot;/2018/06/19/django-channels-websocket-iot-remot
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://dequn.github.io/tags/Docker/"/>
    
      <category term="Docker Compose" scheme="http://dequn.github.io/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>ShadowsocksX-NG kcptun加速配置释疑</title>
    <link href="http://dequn.github.io/2018/06/21/ShadowsocksX-NG-kcptun-settings/"/>
    <id>http://dequn.github.io/2018/06/21/ShadowsocksX-NG-kcptun-settings/</id>
    <published>2018-06-21T14:00:42.000Z</published>
    <updated>2019-01-13T08:00:51.649Z</updated>
    
    <content type="html"><![CDATA[<p>新版<a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">ShadowsocksX-NG</a> 已经自带了kcptun 客户端，这样就不用自己单独启动kcptun进程了。但是<a href="https://github.com/shadowsocks" target="_blank" rel="noopener">shadowsocks团队</a>并没有给出配置示例，导致很多网友对设置含含糊糊，从Google 搜索的第一页结果就可以看出来。</p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/ShadowsocksX-NG/google_search_results.png" alt="搜索ShadowsocksX-NG的结果"></p><p>建立好kcptun服务器端后，运行<code>kcptun.sh show</code>打印出服务器信息，如下。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">可使用的客户端配置文件为:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"localaddr"</span>: <span class="string">":443"</span>,</span><br><span class="line">  <span class="string">"remoteaddr"</span>: <span class="string">"xxx.xxx.xxx.xxx:29900"</span>,</span><br><span class="line">  <span class="string">"key"</span>: <span class="string">"very fast"</span>,</span><br><span class="line">  <span class="string">"crypt"</span>: <span class="string">"aes-128"</span>,</span><br><span class="line">  <span class="string">"mode"</span>: <span class="string">"fast2"</span>,</span><br><span class="line">  <span class="string">"mtu"</span>: <span class="number">1350</span>,</span><br><span class="line">  <span class="string">"sndwnd"</span>: <span class="number">512</span>,</span><br><span class="line">  <span class="string">"rcvwnd"</span>: <span class="number">512</span>,</span><br><span class="line">  <span class="string">"datashard"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">"parityshard"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"dscp"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"nocomp"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"quiet"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端配置如下图。</p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/ShadowsocksX-NG/ShadowsocksX-NG%E9%85%8D%E7%BD%AE%E5%9B%BE.jpg" alt="ShadowsocksX-NG kcptun设置"></p><p>这里说一下经常配置错的地方：</p><ul><li>kcptun Port填写的是服务器端打印出来的那个端口，这个时候上边的端口也会变，不要紧。</li><li><strong>画框处的Password，不是Shadowsocks服务端的密码，是Kcptun服务端打出来的key</strong>，在本文中就是”very fast”，这里是最容易搞混的地方</li><li>其他选项对应填写就行，如果有其他参数不一样，可以在Arguments中填写，比如默认我kcp_client.log中打印出来的sndwnd是128，这里改成512</li><li>有问题先看<code>~/Library/kcptun_client.log</code> 自主分析，对照各个参数</li><li>其他设置不需要改就可以运行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新版&lt;a href=&quot;https://github.com/shadowsocks/ShadowsocksX-NG&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ShadowsocksX-NG&lt;/a&gt; 已经自带了kcptun 客户端，这样就不用自己单独启动
      
    
    </summary>
    
    
      <category term="ShadowsocksX-NG" scheme="http://dequn.github.io/tags/ShadowsocksX-NG/"/>
    
      <category term="kcptun" scheme="http://dequn.github.io/tags/kcptun/"/>
    
  </entry>
  
  <entry>
    <title>基于Django &amp; Channels &amp; WebSocket &amp; Twisted的物联网远程控制</title>
    <link href="http://dequn.github.io/2018/06/19/django-channels-websocket-iot-remote-control/"/>
    <id>http://dequn.github.io/2018/06/19/django-channels-websocket-iot-remote-control/</id>
    <published>2018-06-19T15:34:46.000Z</published>
    <updated>2018-06-20T11:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司业务需要开发IOT从硬件到软件的全部工作，由于一开始来的硬件工程师选择了基于TCP直接进行终端与控制中心交互，自己设计报文内容与格式，所以远程控制也需要自己实现。还是自己太年轻，放着好好的现成的MQTT协议不用，自己瞎折腾。</p><p>硬件终端与服务器的通讯模块采用的是普通的2G卡，这样才能与自己的服务器直接通信（电信的物联网卡只能连接华为云，移动的物联网卡只能连接Oneconnect云平台，然后再对接自己的业务系统）。为了节省终端电池电量，终端5分钟唤醒一次连接服务器上报数据，也就是在这个时候，需要服务器查询控制任务队列，下发给下位机。所以，这里有下面几个工作需要完成：</p><ul><li>前端用户界面操作，发送任务给后端服务器（React + Django)，随后等待得到控制结果状态</li><li>后端创建任务（写Redis)</li><li>下位机每5分钟连接一次上位机，上位机（Twisted）查询任务队列（Redis），将对应的任务下发给下位机，下位机获取控制报执行相应操作后，返回控制结果给上位机</li><li>上位机返回控制结果给web后端(Redis 发布)，后端监听服务（订阅 Redis）返回给前端（WebSocket）</li><li>前端拿到结果，UI反馈给用户</li></ul><p>其中，不是必须通过Web后端才可以给硬件的上位机发送任务（这里是Twisted进程），比如本身就可以使用<a href="https://github.com/crossbario/autobahn-python" target="_blank" rel="noopener">autobahn-python</a>直接搭建一个WAMP，其运行在Twisted上，就可以省去一步交互了。由于在这个项目中涉及到权限验证、开关抽象（一个下位机有多个开关）等工作，所以还把这层放在Django中，反而省去很多开发。</p><p>另外需要说明一下为什么web前后端之间用WebSocket，因为这里的任务相当于<strong>异步任务</strong>，前后端都不知道下位机执行任务的准确时间，除了前端轮询的解决方案，最好的就是建立一个双工长连接，这样当web后端一旦知道任务结果，就可以主动发送给前端，因此WebSocket是最合适的方案。当然，Django本身不支持长连接，幸得有大牛开发了<a href="https://github.com/django/channels" target="_blank" rel="noopener">channels</a>，使得我们可以基于Django开发WebSocet服务，并且还支持异步！</p><p>以上的过程画成图是这样的!</p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/iot-remote-control-sequence.png" alt="iot-remote-control-sequence"></p><p>补充：</p><ul><li>任务队列是写Redis</li><li>注意任务队列消费过后，要删除（即此次任务已执行，不论结果成功与否）</li><li>Django Channels需要建立一个后台监听服务（<a href="https://channels.readthedocs.io/en/latest/topics/channel_layers.html#using-outside-of-consumers" target="_blank" rel="noopener">Channel layers using outside of consumer</a>），第一时间通知给web前端</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司业务需要开发IOT从硬件到软件的全部工作，由于一开始来的硬件工程师选择了基于TCP直接进行终端与控制中心交互，自己设计报文内容与格式，所以远程控制也需要自己实现。还是自己太年轻，放着好好的现成的MQTT协议不用，自己瞎折腾。&lt;/p&gt;
&lt;p&gt;硬件终端与服务器的通讯模块采用
      
    
    </summary>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="Channels" scheme="http://dequn.github.io/tags/Channels/"/>
    
      <category term="WebSocket" scheme="http://dequn.github.io/tags/WebSocket/"/>
    
      <category term="IOT" scheme="http://dequn.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>django-allauth配置微信登陆</title>
    <link href="http://dequn.github.io/2018/06/12/django-allauth-weixin-login/"/>
    <id>http://dequn.github.io/2018/06/12/django-allauth-weixin-login/</id>
    <published>2018-06-12T13:16:50.000Z</published>
    <updated>2018-06-13T14:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://django-allauth.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">django-allauth</a>很方便地继承了第三方登陆的功能，但其说明文档并不是很详细，配置一个demo都捉摸了好长时间，这里就以微信订阅号登陆为例，详细地说明一下配置过程，以供其他新上手地小伙伴参考。</p><h1 id="获取微信订阅号开发appid"><a href="#获取微信订阅号开发appid" class="headerlink" title="获取微信订阅号开发appid"></a>获取微信订阅号开发appid</h1><p>微信公众平台提供了一个测试号方便开发，登陆<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index</a>即可获得一个appID和appsecret，这里但URL和Token都先可以留空，找到下边的<strong>网页授权获取用户基本信息</strong>，点击右侧的修改，测试号可以填写ip地址，这里为填写的是本地开发时候的本机ip:port, <strong>注意：这个地址是要会出现在回掉地址redirect_url中的，不一致将不能正确授权</strong>。【参考：<a href="https://www.cnblogs.com/0201zcr/p/5131602.html" target="_blank" rel="noopener">微信公众平台开发——微信授权登录（OAuth2.0）</a>】</p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/django-allauth/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%8F%B7.png" alt="微信公众平台测试号"></p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/django-allauth/%E6%89%BE%E5%88%B0%E7%BD%91%E9%A1%B5%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt="找到网页获取用户基本信息"></p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/django-allauth/%E5%A1%AB%E5%86%99%E5%9F%9F%E5%90%8D.png" alt="填写域名"></p><h1 id="安装配置django-allauth"><a href="#安装配置django-allauth" class="headerlink" title="安装配置django-allauth"></a>安装配置django-allauth</h1><p>django-allauth 的Doc已经把<a href="https://django-allauth.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">安装过程</a>解释的很详细了，就不再重复，只说明一下比较容易出错的地方。</p><h2 id="site设置"><a href="#site设置" class="headerlink" title="site设置"></a>site设置</h2><p>django-allauth要求设置站点号，如果已经跟着安装过程进行到这一步的话，需要打开django的后台管理程序，会有一个设置好的site(example.com)。</p><h2 id="django-allauth-Social-applications设置"><a href="#django-allauth-Social-applications设置" class="headerlink" title="django-allauth Social applications设置"></a>django-allauth Social applications设置</h2><p>在后台管理找到Social applications，点击添加，把第一步在微信公众平台获取的appid和appsecret填进去，并选择刚刚设置的站点，保存，站点名称不一定需要与微信公众平台填写的一致，这里刚开始理解错了。【参考: <a href="http://www.marinamele.com/user-authentication-with-google-using-django-allauth" target="_blank" rel="noopener">Part VIII – User Authentication with a Google Account using Django Allauth</a>】</p><p><img src="http://obqjd695a.bkt.clouddn.com/blog/django-allauth/%E6%B7%BB%E5%8A%A0social%20application.png" alt="添加social application"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下载一个<a href="https://mp.weixin.qq.com/wiki?action=doc&amp;id=mp1455784140" target="_blank" rel="noopener">微信web开发者工具</a>，输入微信登陆的地址<a href="http://10.0.0.8:8000/accounts/weixin/login/" target="_blank" rel="noopener">http://10.0.0.8:8000/accounts/weixin/login/</a> ，会提示授权、登陆（<code>/accounts/weixin/</code>路径是在django.settings文件中配置的），至此配置结束，在django后台中，可以看到Social accounts和Users两个表新增刚刚登陆的微信用户（allauth默认设置，参考<a href="https://django-allauth.readthedocs.io/en/latest/configuration.html" target="_blank" rel="noopener">Configuration</a>），测试完成！</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>微信公众平台中设置的域名，要和请求授权url中的回掉参数redirect_uri的域名是一模一样的。如果微信公众平台上的是线上域名，本地测试可以修改hosts文件。</p></li><li><p>如果使用allauth.weixin的登陆url，也就是<code>accounts/weixin/login</code>(跟着allauth的文档示例会配置成这样的），那么django的域名一定要与微信公众平台上设置的一致，否则默认的回掉地址是<code>django-domain/accounts/weixin/login/callback</code>，微信授权页面不能正常加载。</p></li><li><p>django-allauth的微信配置（我这里配置的是公众号内网页授权，不是pc端扫描二维码授权）。</p></li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCIALACCOUNT_PROVIDERS = &#123;</span><br><span class="line">    <span class="string">'weixin'</span>: &#123;</span><br><span class="line">        <span class="string">'AUTHORIZE_URL'</span>: <span class="string">'https://open.weixin.qq.com/connect/oauth2/authorize'</span>,</span><br><span class="line">        <span class="string">'SCOPE'</span>: [<span class="string">'snsapi_userinfo'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>[1]. <a href="https://django-allauth.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">django-allauth</a><br>[2]. <a href="https://www.cnblogs.com/0201zcr/p/5131602.html" target="_blank" rel="noopener">微信公众平台开发——微信授权登录（OAuth2.0）</a><br>[3]. <a href="http://www.marinamele.com/user-authentication-with-google-using-django-allauth" target="_blank" rel="noopener">Part VIII – User Authentication with a Google Account using Django Allauth</a><br>[4]. <a href="https://django-allauth.readthedocs.io/en/latest/configuration.html" target="_blank" rel="noopener">Configuration</a><br>[5]. <a href="https://mp.weixin.qq.com/wiki?action=doc&amp;id=mp1455784140" target="_blank" rel="noopener">微信web开发者工具</a><br>[6]. <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">网站应用微信登录开发指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://django-allauth.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;django-allauth&lt;/a&gt;很方便地继承了第三方登陆的功能，但其说
      
    
    </summary>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="allauth" scheme="http://dequn.github.io/tags/allauth/"/>
    
      <category term="微信" scheme="http://dequn.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Django2结合Celery添加定时任务</title>
    <link href="http://dequn.github.io/2018/06/02/django-celery/"/>
    <id>http://dequn.github.io/2018/06/02/django-celery/</id>
    <published>2018-06-01T16:56:26.000Z</published>
    <updated>2018-06-01T18:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目需要对一些观测数值做监控预警，没有找到特别合适的专门的开源项目，因此决定采用Celery实现任务调度，当然，除了Cerlery，还有就是可以采用APScheduler实现，也有<a href="https://github.com/jarekwg/django-apscheduler" target="_blank" rel="noopener">django-apscheduler</a>的开源项目利用Django的ORM存储APScheduler的任务和调度信息，但是APScheduler并没有那么灵活，比如要想修改例行信息，是需要修改源代码并且重启Django进程才可以，也正是参考了这个<a href="https://stackoverflow.com/questions/11654353/how-to-setup-apscheduler-in-a-django-project/15929907" target="_blank" rel="noopener">Stackoverflow问题</a>，才决定选用Celery来调度任务。</p><p>关于Celery的定义，我想其项目网站主页的标题最为精确不过了——<strong>Distributed Task Queue</strong>，这里只简单的介绍一下Celery的工作模式，其他的使用细节可以参看网上的大量文章，不过建议以项目本身的文档为主，最为权威，尤其是在现在网络文章互相抄来抄去，质量极低！</p><p>Celery是一个分布式任务队列，那么就需要一个Broker也就是经纪人（我看好多人翻译成中间人，觉得好low啊）来存储和分发任务消息，Worker是实际执行任务的角色，Worker进程启动后，从经纪人那里读取并执行相应任务，任务是一早定义好的，可以手动调用，也可以用CelerBeat实现例行。如果了解生产者消费者模型的话，Worker对应消费者，CeleryBeat对应生产者。</p><p>也已经有开源项目<a href="https://github.com/celery/django-celery" target="_blank" rel="noopener">django-celery</a>，使得可以很方便的在Django中添加Celery任务，但是这个项目目前不支持Django 2及以上，原因是Celery调用的kombu库会抛出一个<code>missing 1 required positional argument: on_delete</code>的错误，而恰是在Django 2的时候，<code>on_delete</code>改成了必须字段，由于是Docker配置的开发环境，也懒得去修改镜像，因为Celery 本身就有对Django的支持，所以就自己动手，并不复杂。</p><p>具体的过程可以参考<a href="https://medium.com/@markgituma/using-django-2-with-celery-and-redis-21343284827c" target="_blank" rel="noopener">Using Django 2 with Celery and Redis</a> 和 官方文档<a href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html" target="_blank" rel="noopener">Using Celery with Django</a>，很简单就不上代码了，<strong>这里有一个很深的坑</strong>，celery.py中配置了任务自动发现<code>app.autodiscover_tasks()</code>，但<strong>在各个app中定义任务的模块名一定要是tasks，也就是示例代码中定义了任务的文件名一定要是tasks.py，而不能是其他的任何名称</strong>，因为自己尝试的时候手残敲错了，调试了很久才发现！</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> app1/</span></span><br><span class="line"><span class="ruby">    - tasks.py</span></span><br><span class="line"><span class="ruby">    - models.py</span></span><br><span class="line"><span class="ruby">- app2/</span></span><br><span class="line"><span class="ruby">    - tasks.py</span></span><br><span class="line"><span class="ruby">    - models.py</span></span><br></pre></td></tr></table></figure><p>另外还有一个需要注意的问题就是调用任务时<strong>任务的name</strong>该如何写，从哪一层模块开始也至关重要，<a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-naming-relative-imports" target="_blank" rel="noopener">task-naming-relative-imports</a>解释了why and how，这一点很多其他文章都没提及，也是容易出现的一个坑。具体放在Django中，以app1中任务为例，也就是在<code>INSTALLED_APPS</code>中添加的是app1，那么调用的时候要用到的任务名称就是<code>app1.tasks.task1</code>，也可以是嵌套的类如<code>app1.app2.tasks.task1</code>。</p><p>写了一个简单的<a href="https://github.com/dequn/django2-celery-demo" target="_blank" rel="noopener">django2-celery-demo</a>，以供参考。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://stackoverflow.com/questions/11654353/how-to-setup-apscheduler-in-a-django-project/15929907" target="_blank" rel="noopener">Stackoverflow: How to setup APScheduler in a Django project?</a><br>[2]. <a href="https://github.com/celery/django-celery" target="_blank" rel="noopener">django-celery</a><br>[3]. <a href="https://github.com/jarekwg/django-apscheduler" target="_blank" rel="noopener">django-apscheduler</a><br>[4]. <a href="https://medium.com/@markgituma/using-django-2-with-celery-and-redis-21343284827c" target="_blank" rel="noopener">Using Django 2 with Celery and Redis</a><br>[5]. <a href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html" target="_blank" rel="noopener">Using Celery with Django</a><br>[6]. <a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-naming-relative-imports" target="_blank" rel="noopener">task-naming-relative-imports</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目需要对一些观测数值做监控预警，没有找到特别合适的专门的开源项目，因此决定采用Celery实现任务调度，当然，除了Cerlery，还有就是可以采用APScheduler实现，也有&lt;a href=&quot;https://github.com/jarekwg/django-apsc
      
    
    </summary>
    
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="Celery" scheme="http://dequn.github.io/tags/Celery/"/>
    
      <category term="APScheduler" scheme="http://dequn.github.io/tags/APScheduler/"/>
    
  </entry>
  
  <entry>
    <title>python3调用Twisted web request的坑</title>
    <link href="http://dequn.github.io/2018/05/31/python3-twisted-web-client/"/>
    <id>http://dequn.github.io/2018/05/31/python3-twisted-web-client/</id>
    <published>2018-05-31T11:04:59.000Z</published>
    <updated>2019-01-13T08:10:06.072Z</updated>
    
    <content type="html"><![CDATA[<p>硬件终端发送数据给服务器采用的是TCP直接传输，自己定义了二进制数据流格式，选来选去采用了Twisted开发TCP服务器。在数据外露的时候，采用Django开发了一个网站，因为在Django中已经定义了数据模型，不能也不想定义两次数据模型，所以Twisted接收到数据时，调用Django的REST接口保存数据到数据库，这就需要用到Twisted web client 发送数据。<a href="https://stackoverflow.com/questions/5051408/sharing-a-database-between-twisted-and-django" target="_blank" rel="noopener">该回答</a> 分析了在Twisted和Django中“共享数据库”的几种方法。</p><p>注：Twisted到最大优势在于异步非阻塞，而Django采用的是同步处理，如果直接引入Django的数据模型，这种同步处理放在Twisted的deferred里会让Twisted的优势丧失，所以采用了异步调用其他服务的方式。之所以现在采用Django进行网站开发，是因为现在是项目初期，能够快速开发落地是第一需求，但同时也兼顾到以后性能升级，所以保证各个模块的低耦合。</p><p>环境信息：</p><ul><li>Python 3.6.5</li><li>Twisted 18.4.0</li><li>Django 2.0.5</li></ul><p>关于Twisted web client<a href="https://twistedmatrix.com/documents/14.0.1/web/howto/client.html" target="_blank" rel="noopener">官网</a>给出了很详细的示例，但跟着实验下来的情况竟然是没有反应，服务器根本都没接到任何请求！</p><p>程序（参考官方示例）报的第一个错误是<code>TypeError: url must be bytes, not unicode</code>，没在意直接在url的字面量前加了一个<code>b</code>，其实这给后来的debug带来了极大的困难，因为一切都是按照示例写的，而根本看不到发送请求，没有版本只能再去翻看Twisted 的<a href="https://twistedmatrix.com/documents/14.0.1/api/twisted.web.iweb.IAgent.html#request" target="_blank" rel="noopener">API DOC</a>了，这才发现，原来在Python3中，request的绝大多数参数要求是<code>bytes</code>类型，而示例其实是Python2的代码，把所有字符串都转换成<code>bytes</code>，问题解决。</p><p>还有一点需要特别注意的是，request请求的url必须带上<code>http://</code>协议前缀，不然服务器端也是接收不到请求的！</p><p>最后，刚开始写Python3的代码，还真是有些不适应，一些细节需要特别注意。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://twistedmatrix.com/documents/14.0.1/api/twisted.web.iweb.IAgent.html#request" target="_blank" rel="noopener">https://twistedmatrix.com/documents/14.0.1/api/twisted.web.iweb.IAgent.html#request</a><br>[2]. <a href="https://stackoverflow.com/questions/5051408/sharing-a-database-between-twisted-and-django" target="_blank" rel="noopener">Sharing a database between Twisted and Django</a><br>[3]. <a href="https://twistedmatrix.com/documents/14.0.1/web/howto/client.html" target="_blank" rel="noopener">Using the Twisted Web Client</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;硬件终端发送数据给服务器采用的是TCP直接传输，自己定义了二进制数据流格式，选来选去采用了Twisted开发TCP服务器。在数据外露的时候，采用Django开发了一个网站，因为在Django中已经定义了数据模型，不能也不想定义两次数据模型，所以Twisted接收到数据时，调
      
    
    </summary>
    
    
      <category term="Twisted" scheme="http://dequn.github.io/tags/Twisted/"/>
    
      <category term="Django" scheme="http://dequn.github.io/tags/Django/"/>
    
      <category term="Python3" scheme="http://dequn.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Docker的OS image是做什么用的</title>
    <link href="http://dequn.github.io/2018/04/01/why-docker-has-OS-image/"/>
    <id>http://dequn.github.io/2018/04/01/why-docker-has-OS-image/</id>
    <published>2018-04-01T00:41:01.000Z</published>
    <updated>2018-04-01T13:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天闲来无事，简单入门了一下Docker。主要参考的有阮一峰老师的两篇文章——<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a>、<a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker 微服务教程</a>和 yeasy的开源项目<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker — 从入门到实践</a>，照葫芦画瓢简单入门，不过离真正理解认清楚容器的特点、必要性，如何实践在持续交付和部署以及容器云等实际的运维应用还有很长的路要走。当我看到Docker 的OS image例如CentOS/Fedora、Busybox、Alphine等镜像的时候，不禁怀疑，既然我可以docker pull一个很简单命令就可以实现如Nginx, mysql等微服务的启动和部署，那为什么还会存在这些OS image, 这些OS image 的作用是什么？</p><p>在解决这个问题之前，首先需要明白几个和容器以及OS相关的定义，英文比较简单，直接从<a href="http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html" target="_blank" rel="noopener">Understanding Docker “Container Host” vs. “Container OS” for Linux and Windows Containers</a>粘过来了，也强烈建议看看这篇文章，对于理解”OS”很有帮助。</p><blockquote><p><strong>Container Host</strong>: Also called the Host OS. The Host OS is the operating system on which the Docker client and Docker daemon run. In the case of Linux and non-Hyper-V containers, the Host OS shares its kernel with running Docker containers. For Hyper-V each container has its own Hyper-V kernel.<br> <strong>Container OS</strong>: Also called the Base OS. The base OS refers to an image that contains an operating system such as Ubuntu, CentOS, or windowsservercore. Typically, you would build your own image on top of a Base OS image so that you can take utilize parts of the OS. Note that windows containers require a Base OS, while Linux containers do not.<br> <strong>Operating System Kernel</strong>: The Kernel manages lower level functions such as memory management, file system, network and process scheduling.</p></blockquote><h2 id="菜鸟回答"><a href="#菜鸟回答" class="headerlink" title="菜鸟回答"></a>菜鸟回答</h2><p>基于以上信息，已经可以给出我这种菜鸟回答了：Docker的每一个镜像都必须有一个Base OS, 这个Base OS 可以是 Linux 的发行版，也可以是windows的，上边已经提到，这个Base OS 在Host OS 是Linux的时候可以“不必要”，其实，是一种特殊的Base OS 叫做<a href="https://hub.docker.com/r/library/scratch/" target="_blank" rel="noopener">scratch</a>，文章<a href="https://docs.docker.com/develop/develop-images/baseimages/" target="_blank" rel="noopener">Create a base image</a>给出了如何基于scratch创建一个Base Image（Base image 和 Base OS image 不是一样的概念!）。</p><p>我们所使用的常见的image，基本上都是以一个Host OS image为base的， 暨Dockerfile中都会有类似<code>FROM debian:stretch-slim</code>的基于OS image的语句。以nginx 为例，nginx既有基于debian也有基于alpine的镜像，tag分别是nginx:version和nginx:version-alpine，查看其Dockerfile可以看出，最大的不同点在于一个是<code>FROM debian:stretch-slim</code>和<code>FROM alpine:3.7</code>。下载镜像，可以看出其大小的区别，不得不说，基于alpine的和基于debian的镜像大小确实不是一个量级的。文章<a href="https://www.brianchristner.io/docker-image-base-os-size-comparison/" target="_blank" rel="noopener">Docker Base Image OS Size Comparison</a>对不同的Base OS image大小做了一个对比，感兴趣的可以看一看。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               <span class="number">1.13</span><span class="number">.10</span>-alpine      <span class="number">91</span>ce6206f9d8        <span class="number">10</span> days ago         <span class="number">18</span>MB</span><br><span class="line">nginx               <span class="number">1.13</span><span class="number">.10</span>             <span class="number">7</span>f70b30f2cc6        <span class="number">10</span> days ago         <span class="number">109</span>MB</span><br></pre></td></tr></table></figure><h2 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h2><p>文章<a href="https://blog.risingstack.com/operating-system-containers-vs-application-containers/" target="_blank" rel="noopener">Operating System Containers vs. Application Containers</a>讲述了虚拟机和容器的实现上的区别，可以很明白地看到，容器是直接基于Host OS kernel的，这也就是为什么在Mac和Windows上的Docker Client是基于Linux VM的<a href="https://docs.docker.com/develop/develop-images/baseimages/" target="_blank" rel="noopener">[5]</a>。在文章<a href="http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html" target="_blank" rel="noopener">[4]</a>也可以看到，如果是Windows类型的容器，是必须建立在Winndows type的Base image上，或者是一个完整的“虚拟机容器”。</p><p><img src="http://obqjd695a.bkt.clouddn.com/os-virtualization.jpg" alt=""></p><p><a href="https://serverfault.com/questions/659557/os-docker-container-what-is-the-difference-with-a-vm-then" target="_blank" rel="noopener">Stackoverflow</a> 上有一个回答挺不错的，解释了为什么会有Base image，同样贴出原文，可以很明白的看到，Base image 提供的正式容器运行需要的<strong> root filesystem</strong>。</p><blockquote><p>Now you should wonder how is it possible to get a process runing inside a linux base image different from the linux distribution your host is running with. For an OS to run you basically need : </p><ul><li>A boot filesystem : contains the bootloader and the kernel that will reside in memory once loaded. We don’t care about this in the case of Docker containers because the kernel is shared with the host and is the common part between all linux distributions.</li><li>A root filesystem : contains the filesystem structure. It may be different from one linux distribution to another. It’s read-only until the boot sequence has finished.</li></ul></blockquote><p>如果从Docker的分层架构上来看<a href="https://blog.risingstack.com/operating-system-containers-vs-application-containers/" target="_blank" rel="noopener">[8]</a>，为什么需要Base image也会明朗许多。 在另一个 <a href="https://serverfault.com/questions/755607/why-do-we-use-a-os-base-image-with-docker-if-containers-have-no-guest-os" target="_blank" rel="noopener">Stackoverflow</a>上同样有一个不错的回答，这个回答中说的是<strong>userland</strong>，感兴趣的也可以看一下。</p><p><img src="http://obqjd695a.bkt.clouddn.com/docker-layers.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker 微服务教程</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker — 从入门到实践</a></li><li><a href="http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html" target="_blank" rel="noopener">Understanding Docker “Container Host” vs. “Container OS” for Linux and Windows Containers</a></li><li><a href="https://docs.docker.com/develop/develop-images/baseimages/" target="_blank" rel="noopener">Create a base image</a> </li><li><a href="https://www.brianchristner.io/docker-image-base-os-size-comparison/" target="_blank" rel="noopener">Docker Base Image OS Size Comparison</a></li><li><a href="https://blog.risingstack.com/operating-system-containers-vs-application-containers/" target="_blank" rel="noopener">Operating System Containers vs. Application Containers</a></li><li><a href="https://serverfault.com/questions/659557/os-docker-container-what-is-the-difference-with-a-vm-then" target="_blank" rel="noopener">OS docker container: what is the difference with a VM then?</a></li><li><a href="https://serverfault.com/questions/755607/why-do-we-use-a-os-base-image-with-docker-if-containers-have-no-guest-os" target="_blank" rel="noopener">Why do we use a OS Base Image with Docker if containers have no Guest OS?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天闲来无事，简单入门了一下Docker。主要参考的有阮一峰老师的两篇文章——&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="Docker" scheme="http://dequn.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://dequn.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>理解python with语句</title>
    <link href="http://dequn.github.io/2017/12/02/%E7%90%86%E8%A7%A3python-with%E8%AF%AD%E5%8F%A5/"/>
    <id>http://dequn.github.io/2017/12/02/理解python-with语句/</id>
    <published>2017-12-02T05:50:08.000Z</published>
    <updated>2017-12-03T11:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的with语句可谓是相当的好用了，省去了<code>try...finally...</code>的复杂写法，<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">浅谈 Python 的 with 语句</a> 一文写的已经非常详细里，解决了使用过程中的两点疑问。文中的代码清单也主要摘自这篇文章。</p><p>清单1: with语句执行过程<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line"><span class="keyword">exit</span> = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = True   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line">try:</span><br><span class="line">    try:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        with-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    except:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = False</span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> not <span class="keyword">exit</span>(context_manager, *sys.exc_info()):</span><br><span class="line">            raise</span><br><span class="line">    finally:</span><br><span class="line">        <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">        <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">        <span class="keyword">if</span> exc:</span><br><span class="line">            <span class="keyword">exit</span>(context_manager, None, None, None) </span><br><span class="line">            <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure></p><p>从上边的逻辑可以看出，1.如果with语句块发生异常，那么执行except中的流程释放资源，并根据<code>exit()</code>函数返回值决定是否向上抛出异常；2.如果执行过程无异常，那么走finally中的逻辑释放资源。</p><h2 id="1-还用不用处理异常？"><a href="#1-还用不用处理异常？" class="headerlink" title="1. 还用不用处理异常？"></a>1. 还用不用处理异常？</h2><p>异常是必须处理的, with语句解决的只是保证了finally中的语句的执行，在with语句块内发生了异常而有没有处理，那么会直接执行with所代替的finally中的语句，并抛出异常给外层上下文，和正常情况下的异常处理流程是一样的。</p><h2 id="2-如果-exit-内部异常？"><a href="#2-如果-exit-内部异常？" class="headerlink" title="2. 如果__exit__内部异常？"></a>2. 如果<code>__exit__</code>内部异常？</h2><p>引用文章<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">浅谈 Python 的 with 语句</a> 中的解释:</p><blockquote><p>退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回<br>True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否 <strong>exit</strong>() 失败来处理异常</p></blockquote><p>通过例子来看一下：</p><ul><li>with语句块异常，但正确释放资源</li></ul><p>清单2: 自定义支持 with 语句的对象</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyResource</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, tag)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.tag = tag</span><br><span class="line">    print <span class="string">'Resource [%s]'</span> % tag</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    print <span class="string">'[Enter %s]: Allocate resource.'</span> % <span class="keyword">self</span>.tag</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>   <span class="comment"># 可以返回不同的对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(<span class="keyword">self</span>, exc_type, exc_value, exc_tb)</span></span><span class="symbol">:</span></span><br><span class="line">    print <span class="string">'[Exit %s]: Free resource.'</span> % <span class="keyword">self</span>.tag</span><br><span class="line">    <span class="keyword">if</span> exc_tb is <span class="symbol">None:</span></span><br><span class="line">        print <span class="string">'[Exit %s]: Exited without exception.'</span> % <span class="keyword">self</span>.tag</span><br><span class="line">    <span class="symbol">else:</span></span><br><span class="line">        print <span class="string">'[Exit %s]: Exited with exception raised.'</span> % <span class="keyword">self</span>.tag</span><br><span class="line">    <span class="keyword">return</span> False   <span class="comment"># 可以省略，缺省的None也是被看做是False</span></span><br></pre></td></tr></table></figure><p>清单3: with语句块引起异常<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    <span class="keyword">with</span> DummyResource(<span class="symbol">'With</span>-<span class="keyword">Exception</span>'):</span><br><span class="line">         print '[<span class="keyword">with</span>-<span class="keyword">body</span>] Run <span class="keyword">with</span> <span class="keyword">exception</span>.'</span><br><span class="line">         <span class="keyword">raise</span> <span class="keyword">Exception</span>(<span class="symbol">'with</span>-block <span class="keyword">exception</span>')</span><br><span class="line">         print '[<span class="keyword">with</span>-<span class="keyword">body</span>] Run <span class="keyword">with</span> <span class="keyword">exception</span>. Failed to finish statement-<span class="keyword">body</span>!'</span><br><span class="line">except <span class="keyword">Exception</span> as e:</span><br><span class="line">    print e</span><br></pre></td></tr></table></figure></p><p>执行上边的代码，可以看到打印的信息，释放完资源后，异常抛出给with外层进行处理，如果外层没有<code>try</code>语句的话，在本例中会由系统打印调用栈并退出。<br>如果<code>__exit__</code>返回True，那么打印信息的最后一行<code>with-block exception</code>将不会被打印，因为with语句释放完资源后，把这个异常“压”下来了。<br>清单4: 正常释放资源，抛出原有异常<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Enter <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Allocate resource.</span><br><span class="line">[<span class="keyword">with</span>-<span class="keyword">body</span>] Run <span class="keyword">with</span> <span class="keyword">exception</span>.</span><br><span class="line">[<span class="keyword">Exit</span> <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Free resource.</span><br><span class="line">[<span class="keyword">Exit</span> <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Exited <span class="keyword">with</span> <span class="keyword">exception</span> raised.</span><br><span class="line"><span class="keyword">with</span>-block <span class="keyword">exception</span></span><br></pre></td></tr></table></figure></p><p>稍微对上边的代码修改一下，在<code>__exit__</code>函数中重新抛出一个异常，如清单5，重新执行清单3的调用，得到清单6的结果。<br>清单5：<code>__exit__</code>抛出异常<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, exc_tb)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[Exit %s]: Free resource.'</span> % self.tag</span><br><span class="line">    <span class="keyword">if</span> exc_tb <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited without exception.'</span> % self.tag</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited with exception raised.'</span> % self.tag</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'new exception in __exit__'</span>)</span><br></pre></td></tr></table></figure></p><p>清单6: <code>__exit__</code>抛出新异常执行结果<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Resource [<span class="keyword">With</span>-<span class="keyword">Exception</span>]</span><br><span class="line">[Enter <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Allocate resource.</span><br><span class="line">[<span class="keyword">with</span>-<span class="keyword">body</span>] Run <span class="keyword">with</span> <span class="keyword">exception</span>.</span><br><span class="line">[<span class="keyword">Exit</span> <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Free resource.</span><br><span class="line">[<span class="keyword">Exit</span> <span class="keyword">With</span>-<span class="keyword">Exception</span>]: Exited <span class="keyword">with</span> <span class="keyword">exception</span> raised.</span><br><span class="line">__exit__ <span class="keyword">exception</span>.</span><br></pre></td></tr></table></figure></p><p>可以看出，如果<code>__exit__</code>重新抛出了一个异常，就会覆盖掉原有异常，如果资源正常释放，只需要返回False或者True来表示是否将with语句的异常抛给外层调用。</p><h2 id="3-其他使用"><a href="#3-其他使用" class="headerlink" title="3.其他使用"></a>3.其他使用</h2><p>使用contextmanager装饰器、nested函数、closing上下文管理器等语法可以参考<br>【<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">浅谈 Python 的 with 语句</a>】或者 【<a href="https://docs.python.org/release/2.6.6/library/contextlib.html" target="_blank" rel="noopener">contextlib — Utilities for with-statement contexts</a>】等文章，不再赘述。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">浅谈 Python 的 with 语句</a></li><li><a href="https://docs.python.org/release/2.6.6/library/contextlib.html" target="_blank" rel="noopener">contextlib — Utilities for with-statement contexts</a></li><li><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="noopener">PEP 343 – The “with” Statement</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python中的with语句可谓是相当的好用了，省去了&lt;code&gt;try...finally...&lt;/code&gt;的复杂写法，&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://dequn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关于目前工作的一点感想</title>
    <link href="http://dequn.github.io/2017/11/21/%E5%85%B3%E4%BA%8E%E7%9B%AE%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/"/>
    <id>http://dequn.github.io/2017/11/21/关于目前工作的一点感想/</id>
    <published>2017-11-21T14:39:37.000Z</published>
    <updated>2017-12-02T05:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>从7月份入职以来，时时感觉到目前的工作跟我所期望的差别很大，但又不知道该如何取舍。</p><p>在面试的时候，经理问我是否愿意从事一些产品相关的工作，由于是岗位是机器学习，所以我想那么即使是产品相关，最起码也是要用到机器学习的，不论是数学层面、算法层面还是架构层面，这样是比较符合我的预期的，所以就签合同入职。可是入职这么久以来，发现当初没有对岗位做更多的了解，是很大的一个坑，这也是校招的同学普遍遇到的一个难点和痛点，除非是在公司以及组内部亲自实习过。</p><p>倒不是说这几个月来没有成长，而是在我所期望的技术以及能力层面上收效甚少。除了维护一些遗留下来的旧产品模块儿，就只剩下一个热词了。在入职以后，我也不得不承认自己与科班出身的同学差距比较大，同样的一个东西我可能需要吭哧好久，但是除了一些业务上的熟悉之外，没有得到更多我想要的成长了，而业务上的东西是带不走的，虽然熟悉公司内部的业务很重要。</p><p>原本也想着身处一个国内相对较好的技术环境内，再加上自己的学习，肯定能进步特别多。现在看来也是太天真了，团队技术是不错，每两周也会有分享，这些也都是有用的，但是收效也少。最为担心的事情是根本就没有自己的事件，每天醒来上班知道晚上回去，需求特别多，想在自己的方向上进行一些积累就显得欲求无门了。我层怀疑公司内部都是这么忙的，和一个从别的组转岗过来的同学，他说他们原来的组没有这边事情这么多，每天还是有很多自己学习、积累的时间，只有大搜才这么忙。</p><p>总说时间是海绵里的水，上高中时班主任也经常说我就是人太懒，当时还很不服气——自觉还不错。现在回想起来，我的自制力确实很弱，比如下班之后我是看不进去任何东西的（尤其是现在），在周六日的时候一个懒觉就占用了很多时间。也可能是我忘记了、放弃了曾经想要的，按现在这种状态下去也必定只能放弃，特别羡慕那些能够白天高效工作、晚上仍能坚持充电的牛人。还有就是白天的效率也不高，总觉得像是被KPI推动的走，没有主动性了。</p><p>如果这样久了，就没有跳出现有生活的动力和能力了；如果现在就跳出来，也没有那个能力，更是不能利用好目前这样一个平台。因此，还得必须自制自律，吃得苦中苦，方觉不知苦。</p><p>都说不忘初心，方得始终。初心是什么千万不能忘记，而为了初心，也定要付出更多才行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从7月份入职以来，时时感觉到目前的工作跟我所期望的差别很大，但又不知道该如何取舍。&lt;/p&gt;
&lt;p&gt;在面试的时候，经理问我是否愿意从事一些产品相关的工作，由于是岗位是机器学习，所以我想那么即使是产品相关，最起码也是要用到机器学习的，不论是数学层面、算法层面还是架构层面，这样是
      
    
    </summary>
    
      <category term="个人日记" scheme="http://dequn.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="工作与初心" scheme="http://dequn.github.io/tags/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%88%9D%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串格式化</title>
    <link href="http://dequn.github.io/2017/10/05/python-str-formation/"/>
    <id>http://dequn.github.io/2017/10/05/python-str-formation/</id>
    <published>2017-10-05T09:24:10.000Z</published>
    <updated>2017-12-02T05:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python的时间也不短了，可是对字符串格式化的方式还是不怎么了解，尤其是对于自定义类型，如何实现友好的格式化输出？</p><p>printf-style的字符串格式化”%”号操作符的使用方法就不再赘述了，如果”%”后面不止一个参数，那么需要传入一个tuple，或者是一个dict。</p><p>由于”%”使用并不是那么方便，在非dict参数的情况下，tuple需要按照顺序组织，并且同一个参数不能够多次使用[<a href="https://mail.python.org/pipermail/python-3000/2006-April/000285.html" title="[Python-3000] String formating operations in python 3k" target="_blank" rel="noopener">1</a>]。于是就提出了使用模板进行字符串格式化的方法[<a href="https://www.python.org/dev/peps/pep-3101/#id9" title="PEP 3101 -- Advanced String Formatting" target="_blank" rel="noopener">2</a>]。这两种方法有在功能上有一定的重复，如何选择也全看个人喜好。</p><p>相对来说，模板格式化字符串功能更为强大和灵活，其语法可以参考[<a href="https://docs.python.org/3/library/string.html#formatstrings" title="string — Common string operations" target="_blank" rel="noopener">3</a>]，下面主要关注自定义类的格式化显示。</p><ul><li>在使用”%”操作符时，后面的转换字符代表的含义[<a href="https://docs.python.org/3/library/stdtypes.html#string-formatting-operations" target="_blank" rel="noopener">4</a>]:<blockquote><p>  ‘r’ String (converts any Python object using repr()).<br>  ‘s’    String (converts any Python object using str()).<br>  ‘a’    String (converts any Python object using ascii()).</p></blockquote></li></ul><p>对应的，我们可以定义自定义类的<code>__repr__()</code>、<code>__str__()</code> 来实现格式化输出（<code>ascii()</code>同<code>repr()</code>一样调用<code>__repr__()</code>，但会对non-ASCII字符进行转义，结果形如\x, \u, \U等[<a href="https://docs.python.org/3/library/functions.html#ascii" title="Built-in Functions" target="_blank" rel="noopener">5</a>]）。</p><ul><li>使用模板格式化时，我们除了可以使用内置的<code>!s</code>、<code>!r</code>、<code>!a</code>转换实现与上边相同的效果外，还可以通过定义类的<code>__format__</code>实现自定义格式化方法，这样就非常灵活了，线面通过例子来看一下。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">class Test:</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'in __str__()'</span></span><br><span class="line"></span><br><span class="line">    def __format__(self, format_spec):</span><br><span class="line">        <span class="keyword">if</span> format_spec == <span class="string">'own1'</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'in __format__(), own1 method'</span></span><br><span class="line">        <span class="keyword">elif</span> format_spec == <span class="string">'s'</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'in __format__(), s method'</span></span><br><span class="line">        <span class="keyword">elif</span> format_spec == <span class="string">'h'</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'in __format__(), h method'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'in __format__(), default method'</span></span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'in __repr__()'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span> = Test()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'str(test) shows '</span> + str(<span class="built_in">test</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'repr(test) shows '</span> + repr(<span class="built_in">test</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'\n-----------% format ----------'</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'%%s shows %s'</span> % <span class="built_in">test</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'%%r shows %r'</span> % <span class="built_in">test</span></span><br><span class="line">    <span class="comment"># print '%%h shows %h' % test # will cause  ValueError: incomplete format</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'\n---------template format --------'</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;&#125;&#125; shows &#123;&#125;'</span>.format(<span class="built_in">test</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;!r&#125;&#125; shows &#123;!r&#125;'</span>.format(<span class="built_in">test</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;!s&#125;&#125; shows &#123;!s&#125;'</span>.format(<span class="built_in">test</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'\n---------template use __format__() --------'</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;:s&#125;&#125; shows &#123;:s&#125;'</span>.format(<span class="built_in">test</span>) <span class="comment"># use __format__ s conversion</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;:h&#125;&#125; shows &#123;:h&#125;'</span>.format(<span class="built_in">test</span>) <span class="comment"># use __format__ h conversion</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;:own1&#125;&#125; shows &#123;:own1&#125;'</span>.format(<span class="built_in">test</span>) <span class="comment"># use __format__ own1 conversion</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'&#123;&#123;:&#125;&#125; shows &#123;:&#125;'</span>.format(<span class="built_in">test</span>) <span class="comment"># use __format__ default conversion</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">str(test) shows <span class="keyword">in</span> __str__()</span><br><span class="line">repr(test) shows <span class="keyword">in</span> __repr__()</span><br><span class="line"></span><br><span class="line">-----------% format ----------</span><br><span class="line">%s shows <span class="keyword">in</span> __str__()</span><br><span class="line">%r shows <span class="keyword">in</span> __repr__()</span><br><span class="line"></span><br><span class="line">---------template format --------</span><br><span class="line">&#123;&#125; shows <span class="keyword">in</span> __format__(),<span class="built_in"> default </span>method</span><br><span class="line">&#123;!r&#125; shows <span class="keyword">in</span> __repr__()</span><br><span class="line">&#123;!s&#125; shows <span class="keyword">in</span> __str__()</span><br><span class="line"></span><br><span class="line">---------template use __format__() --------</span><br><span class="line">&#123;:s&#125; shows <span class="keyword">in</span> __format__(), s method</span><br><span class="line">&#123;:h&#125; shows <span class="keyword">in</span> __format__(), h method</span><br><span class="line">&#123;:own1&#125; shows <span class="keyword">in</span> __format__(), own1 method</span><br><span class="line">&#123;:&#125; shows <span class="keyword">in</span> __format__(),<span class="built_in"> default </span>method</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果只是实现简单的格式化，那么”%”和模板都可以实现，自定义类通过定义<code>__str__()</code>和<code>__repr__()</code>来实现，但如果需要对一个类实现（多种）自定义转换的格式化，那么需要定义类的<code>__format__()</code>方法，并且只能通过使用模板来实现自定义转换的格式化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mail.python.org/pipermail/python-3000/2006-April/000285.html" title="[Python-3000] String formating operations in python 3k" target="_blank" rel="noopener">[Python-3000] String formating operations in python 3k</a></li><li><a href="https://www.python.org/dev/peps/pep-3101/#id9" title="PEP 3101 -- Advanced String Formatting" target="_blank" rel="noopener">PEP 3101 – Advanced String Formatting</a></li><li><a href="https://docs.python.org/3/library/string.html#formatstrings" title="string — Common string operations" target="_blank" rel="noopener">string — Common string operations</a></li><li><a href="https://docs.python.org/3/library/stdtypes.html#string-formatting-operations" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html#string-formatting-operations</a></li><li><a href="https://docs.python.org/3/library/functions.html#ascii" title="Built-in Functions" target="_blank" rel="noopener">Built-in Functions</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Python的时间也不短了，可是对字符串格式化的方式还是不怎么了解，尤其是对于自定义类型，如何实现友好的格式化输出？&lt;/p&gt;
&lt;p&gt;printf-style的字符串格式化”%”号操作符的使用方法就不再赘述了，如果”%”后面不止一个参数，那么需要传入一个tuple，或者是
      
    
    </summary>
    
      <category term="Python" scheme="http://dequn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://dequn.github.io/tags/Python/"/>
    
      <category term="格式化" scheme="http://dequn.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python模块的相对导入和绝对导入</title>
    <link href="http://dequn.github.io/2017/09/17/ways-of-python-import/"/>
    <id>http://dequn.github.io/2017/09/17/ways-of-python-import/</id>
    <published>2017-09-17T05:25:27.000Z</published>
    <updated>2017-09-17T07:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始用Python写代码，对于import的方式不是很理解，尤其是导入上层包的模块时，经常会使用<code>sys.path.append(&#39;..&#39;)</code>，然后再import，很不优雅，所以花些时间全部梳理一遍。</p><p>首先需要明白明白两个概念<strong>包</strong>和<strong>模块</strong>，很多人也都了解，贴出<a href="http://www.runoob.com/python/python-modules.html" title="http://www.runoob.com/python/python-modules.html" target="_blank" rel="noopener">runoob</a>（页面跟W3C好像，他们有什么关系吗？）上给出的两个定义。</p><ul><li><p>模块</p><blockquote><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。<br>模块让你能够有逻辑地组织你的 Python 代码段。<br>把相关的代码分配到一个模块里能让你的代码更好用，更易懂。<br>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p></blockquote></li><li><p>包</p><blockquote><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。<br>简单来说，包就是文件夹，但该文件夹下必须存在 <code>__init__.py</code> 文件, 该文件的内容可以为空。<code>__int__.py</code>用于标识当前文件夹是一个包。</p></blockquote></li></ul><p>从顶层模块（sys.path）或者当前的包中导入模块，使用<code>import module</code>或者<code>from module import xxx</code>的方式就不再赘述，不过有一种使用括号进行的多模块导入方式，如：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">from</span> from <span class="type">Tkinter</span> <span class="keyword">import</span> (<span class="type">Tk</span>, <span class="type">Frame</span>, <span class="type">Button</span>, <span class="type">Entry</span>, <span class="type">Canvas</span>, <span class="type">Text</span>,</span><br><span class="line">    <span class="type">LEFT</span>, <span class="type">DISABLED</span>, <span class="type">NORMAL</span>, <span class="type">RIDGE</span>, <span class="type">END</span>)</span><br></pre></td></tr></table></figure></p><p>这样可以避免使用反斜杠续行，稍微优雅一些，多行的字符串也可以使用一样的括号语法实现。记住，<code>from module import *</code>是绝对的不推荐的，会意外地“污染”命名空间。</p><p><strong>相对导入和绝对导入</strong>是这次讨论的重点，在项目中，肯定不意外地会建立不同层级和结构关系的包，那么在这些包之间，我们又应该如何导入要引用的模块？</p><h1 id="绝对导入"><a href="#绝对导入" class="headerlink" title="绝对导入"></a>绝对导入</h1><p>在Python 2.4之前，如果使用了<code>import foo</code>，如果当前包内也有一个模块foo，由于解释器是不知道你导入的是顶层模块还是当前包内的模块，根据模块寻找加载的顺序[]，当前包内的foo模块就会覆盖掉顶层的foo模块，而可能引起不必要的歧义。于是要求foo必须是在sys.path中能够寻到的模块或包，这就是绝对导入的定义。python-dev 社区选择将绝对导入作为默认导入的方式，一来是因为更常用，二是因为绝对导入可以提供相对导入的全部功能.</p><p>在Python 2.5 和 2.6中，绝对导入是可选的，需要在文件开头添加<code>from __future__ import absolute_import</code>来实现默认的绝对导入。</p><h1 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h1><p>相对导入是根据模块的<code>__name__</code>属性来决定模块的位置，然后计算相对路径，在同一个项目相邻层级的包和模块中最为常用，也最为方便。关于相对导入的语法实现模式，有一个很有趣也很广泛的讨论，看着那些先驱开发者的讨论，收获也是蛮多的，感兴趣的参考<a href="https://www.python.org/dev/peps/pep-0328/" title="PEP 328 -- Imports: Multi-Line and Absolute/Relative" target="_blank" rel="noopener">PEP 328 – Imports: Multi-Line and Absolute/Relative</a>。最后，Guido采用”.”前缀表示相对导入，和Unix系统中的目录表示含义一样，一个”.”表示当年层级，多一个就表示向上一层。下面是一些例子：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .moduleY <span class="keyword">import</span> spam</span><br><span class="line"><span class="keyword">from</span> .moduleY <span class="keyword">import</span> spam <span class="keyword">as</span> ham</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> moduleY</span><br><span class="line"><span class="keyword">from</span> ..subpackage1 <span class="keyword">import</span> moduleY</span><br><span class="line"><span class="keyword">from</span> ..subpackage2.moduleZ <span class="keyword">import</span> eggs</span><br><span class="line"><span class="keyword">from</span> ..moduleA <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> ...package <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> ...sys <span class="keyword">import</span> path</span><br></pre></td></tr></table></figure></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>相对导入必须使用 <code>from .&lt;&gt; import xxx</code>(并且至少含有一个.符号)的模式，<code>import &lt;&gt;</code>总是绝对导入，当然，如果<code>from &lt;&gt; import</code>中没有句点，那么也是绝对导入。但是类似<code>import .foo</code>的方式是非合法语句，因为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import XXX<span class="selector-class">.YYY</span><span class="selector-class">.ZZZ</span></span><br></pre></td></tr></table></figure></p><p>的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX<span class="selector-class">.YYY</span><span class="selector-class">.ZZZ</span></span><br></pre></td></tr></table></figure></p><p>是可用的表达式，而<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> .moduleY</span><br></pre></td></tr></table></figure></p><p>的<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.moduleY</span></span><br></pre></td></tr></table></figure></p><p>不是一个可用的表达式。</p><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>使用相对导入还是绝对导入，可以完全凭个人喜好。但是为了代码的可阅读性，一般的共识是不超过两层的层级可以使用相对导入，试想一下，如果有超过3个的”.”，还能够正确快速地知道向上到了哪个层级吗?这个时候使用绝对导入会更加方便，代码也更好维护。不论哪一种导入方式，也都会有重构时的麻烦（如重命名一个模块），但是我想在IDE如此普遍使用的情况下，这个因素应该是最不值得考虑的了。加一个TODO吧，参阅一些优秀的开源框架源码，看看他们是如何组织的。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>使用了相对导入以后，如果直接以<code>python script_name.py</code>的方式运行脚本，Python解释器会报<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#python 2</span></span><br><span class="line"><span class="symbol">ValueError:</span> Attempted relative import <span class="keyword">in</span> non-package</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#python 3</span></span><br><span class="line">SystemError: Parent <span class="keyword">module</span> <span class="string">''</span> <span class="keyword">not</span> loaded, cannot perform relative <span class="keyword">import</span></span><br></pre></td></tr></table></figure></p><p>的错误，可以使用<code>python -m script_name.py</code>加上-m开关的方式运行，-m用于告诉解释器以脚本的方式运行模块，具体这样做的原因将在下一篇文章中分析。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://kuanghy.github.io/2016/07/21/python-import-relative-and-absolute" title="Python 相对导入与绝对导入" target="_blank" rel="noopener">Python 相对导入与绝对导入</a></li><li><a href="http://www.runoob.com/python/python-modules.html" title="http://www.runoob.com/python/python-modules.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-modules.html</a></li><li><a href="https://www.python.org/dev/peps/pep-0328/" title="PEP 328 -- Imports: Multi-Line and Absolute/Relative" target="_blank" rel="noopener">PEP 328 – Imports: Multi-Line and Absolute/Relative</a></li><li><a href="http://codingpy.com/article/python-import-101/" title="Python导入模块的几种姿势" target="_blank" rel="noopener">Python导入模块的几种姿势</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始用Python写代码，对于import的方式不是很理解，尤其是导入上层包的模块时，经常会使用&lt;code&gt;sys.path.append(&amp;#39;..&amp;#39;)&lt;/code&gt;，然后再import，很不优雅，所以花些时间全部梳理一遍。&lt;/p&gt;
&lt;p&gt;首先需要明白明白两
      
    
    </summary>
    
      <category term="Python" scheme="http://dequn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://dequn.github.io/tags/Python/"/>
    
      <category term="import" scheme="http://dequn.github.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>终端高效切换编码</title>
    <link href="http://dequn.github.io/2017/09/05/switch-encoding-in-terminal/"/>
    <id>http://dequn.github.io/2017/09/05/switch-encoding-in-terminal/</id>
    <published>2017-09-05T12:51:21.000Z</published>
    <updated>2017-12-02T05:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的时候，终端编码通通设置的都是UTF-8，即使有一两台远程机，因为有自主权也都是UTF-8编码，包括数据库表格，也都是统一UTF-8编码，不得不说这样统一以后非常方便，几乎也没有考虑过编码不同带来的烦恼。</p><p>来到公司工作一段时间后才发现，自己的开发机还好说，设置成UTF-8就可以了，保持原有惯例。然而，需要经常登录别的机器看任务跑代码就会发现乱码了，好吧，手动把终端(iTerm2)调到GBK，结束以后再调回来；然后过了没两天，会发现其他机器的Mysql表格也是GBK的，好吧还得暂调GBK。最大的问题还不在于麻烦，我一个终端下连接了多台服务器和数据库，编码都不统一，这可怎么办？</p><p>在网上找到了两种方案，第一种是基于iTerm2的，可以参考<a href="http://blog.chenxiaosheng.com/posts/2013-10-29/mac_osx_iterm2_utf8_gbk_switch.html" target="_blank" rel="noopener">Mac OSX iTerm2 终端UTF-8和GBK编码自由切换</a>，虽然我是iTerm2的用户，但是觉得这种方法还是有些麻烦，如果我不用iTerm2还不能解决了？</p><p>当然还有其他利器，那就是luit.</p><p>参考IBM Knowledge Center上的介绍<a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_61/com.ibm.aix.cmds3/luit.htm" target="_blank" rel="noopener">luit 命令</a></p><blockquote><p>luit 命令是一个过滤器，在任意应用程序和 UTF-8 终端仿真器之间运行。luit 命令将应用程序输出从语言环境的编码转换为 UTF-8，并将终端输入从 UTF-8 转换为语言环境的编码。</p><blockquote><p>注：<br>多语言应用程序必须设置为仅生成 UTF-8 代码。不得使用命令生成 UTF-8 之外的输出。</p></blockquote></blockquote><p>luit的安装也非常简单，参考 <a href="https://blog.jamespan.me/2015/06/12/luit-with-tmux" target="_blank" rel="noopener">Tmux、Luit 杂谈</a>过程如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -c ftp:<span class="comment">//invisible-island.net/luit/luit.tar.gz</span></span><br><span class="line">tar -xzvf luit<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">cd luit-<span class="number">20141204</span>/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>其使用可以man一下，或者参考<a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_61/com.ibm.aix.cmds3/luit.htm" target="_blank" rel="noopener">luit 命令</a>，下面简单给出两个示例。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">luit </span>-encoding gbk ssh relay-mechine</span><br><span class="line"><span class="comment"># 这样登录远程机器用的就是GBK编码了</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">luit </span>-encoding gbk mysql -u mysql_user -p </span><br><span class="line"><span class="comment">#这样连接数据库用的也是GBK编码</span></span><br></pre></td></tr></table></figure><p>最后不得不吐槽一下我司，是因为出于历史原因吗，固守GBK阵营？</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_61/com.ibm.aix.cmds3/luit.htm" target="_blank" rel="noopener">luit 命令</a></li><li><a href="https://blog.jamespan.me/2015/06/12/luit-with-tmux" target="_blank" rel="noopener">Tmux、Luit 杂谈</a></li><li><a href="http://blog.chenxiaosheng.com/posts/2013-10-29/mac_osx_iterm2_utf8_gbk_switch.html" target="_blank" rel="noopener">Mac OSX iTerm2 终端UTF-8和GBK编码自由切换</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在以前的时候，终端编码通通设置的都是UTF-8，即使有一两台远程机，因为有自主权也都是UTF-8编码，包括数据库表格，也都是统一UTF-8编码，不得不说这样统一以后非常方便，几乎也没有考虑过编码不同带来的烦恼。&lt;/p&gt;
&lt;p&gt;来到公司工作一段时间后才发现，自己的开发机还好说
      
    
    </summary>
    
      <category term="Linux" scheme="http://dequn.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://dequn.github.io/tags/Linux/"/>
    
      <category term="Encoding" scheme="http://dequn.github.io/tags/Encoding/"/>
    
  </entry>
  
</feed>
